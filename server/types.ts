import {
	AuthenticationResponseJSON,
	PublicKeyCredentialCreationOptionsJSON,
	PublicKeyCredentialRequestOptionsJSON,
	RegistrationResponseJSON,
} from "@simplewebauthn/server/esm/deps";
import { FastifyReply, FastifyRequest } from "fastify";
import { ROLES } from "./constants.js";

export interface JWT_REGISTERED_CLAIMS {
	/**
	 * Identifies the principal that issued the JWT. It specifies the issuer of the token.
	 */
	iss?: string;
	/**
	 * Identifies the principal that is the subject of the JWT. It typically represents the user or entity associated with the token.
	 */
	sub?: Buffer;
	/**
	 * Specifies the recipients that the JWT is intended for. It limits the usability of the token to a particular audience.
	 */
	aud?: string;
	/**
	 * Specifies the expiration time after which the JWT should not be accepted for processing. It provides a time limit on the tokenâ€™s validity.
	 */
	exp?: number;
	/**
	 * Specifies the time before which the JWT must not be accepted for processing. It indicates the time when the token becomes valid.
	 */
	nbf?: number;
	/**
	 * Specifies the time at which the JWT was issued. It can be used to determine the age of the token.
	 */
	iat?: number;
	/**
	 * Provides a unique identifier for the JWT. It can be used to prevent JWT reuse and to maintain token uniqueness.
	 */
	jti?: string;
	/**
	 * Custom claim asserting whether the user is an administrator.
	 */
	adm?: boolean;
	/**
	 * Custom claim containing user roles (e.g. admin, moderator, etc...) by their role ids.
	 */
	rls?: number[];
	/**
	 * Custom claim representing the user's first name.
	 */
	fnm?: string;
	/**
	 * Custom claim representing the user's last name.
	 */
	lnm?: string;
	/**
	 * Custom claim. Recommended that the key length is 3 characters long.
	 */
	[key: string]: any;
}

export interface LoginStatus {
	/**
	 * The JWT payload.
	 */
	payload: JWT_REGISTERED_CLAIMS | null;
	/**
	 * Whether the JWT is valid. This takes into account expiration, revocation, etc.
	 */
	valid: boolean;
	/**
	 * An object containing the cookies to be set in the response.
	 */
	setCookies: SetCookieOptions[];
	/**
	 * An array of error messages.
	 */
	errors?: string[];
}

export interface RevokedRefreshToken {
	/**
	 * The id of the revoked refresh token, generated by UUIDv4 and represented as a Buffer.
	 */
	token_id: Buffer;
	/**
	 * The expiration time of the revoked refresh token.
	 */
	expires_at: Date;
}

export interface Email {
	/**
	 * The email text.
	 */
	email: string;
	/**
	 * Is the email primary?
	 */
	is_primary: boolean;
	/**
	 * The time at which the email was created.
	 */
	created_at: Date;
}
export interface Passkey {
	/**
	 * The id of the passkey, generated by UUIDv4 and represented as a Buffer.
	 */
	id: Buffer;
	/**
	 * The id of the user who owns the passkey, generated by UUIDv4 and represented as a Buffer.
	 */
	user_id?: Buffer;
	/**
	 * The credential id of the passkey.
	 */
	credential_id: string;
	/**
	 * The public key of the passkey.
	 */
	public_key: string;
	/**
	 * Counter.
	 */
	counter: number;
	/**
	 * Passkey transports.
	 */
	transports: string;
}
export class User {
	/**
	 * The user's email addresses.
	 */
	emails?: Email[];
	/**
	 * The user's roles as an array of role ids
	 */
	role_ids?: number[];
	/**
	 * The user's roles.
	 */
	roles?: string[];
	/**
	 * The user's passkeys.
	 */
	passkeys?: Passkey[];
	/**
	 * The id of the user, generated by UUIDv4 and represented as a Buffer.
	 */
	id: Buffer;
	/**
	 * The salt of the password, generated by UUIDv4 and represented as text.
	 */
	salt?: Buffer | null;
	/**
	 * The hashed password of the user, represented as text.
	 */
	password?: Buffer | null;
	/**
	 * The date the user was created.
	 */
	created_at?: Date;
	/**
	 * The users first name.
	 */
	first_name?: string;
	/**
	 * The users last name.
	 */
	last_name?: string;
	constructor({
		emails,
		role_ids,
		roles,
		passkeys,
		id,
		salt,
		password,
		created_at,
		first_name,
		last_name,
	}: {
		emails?: Email[];
		role_ids?: number[];
		roles?: string[];
		passkeys?: Passkey[];
		id:
			| Buffer
			| {
					type: "Buffer";
					data: number[];
			  };
		salt?: Buffer | null;
		password?: Buffer | null;
		created_at?: Date;
		first_name?: string;
		last_name?: string;
	}) {
		this.emails = emails;
		this.passkeys = passkeys;
		if (!(id instanceof Buffer)) {
			id = Buffer.from(id.data);
		}
		this.id = id;
		this.salt = salt;
		this.password = password;
		this.created_at = created_at;
		this.first_name = first_name;
		this.last_name = last_name;
		this.setRoles(role_ids ?? roles ?? []);
	}
	setRoles(roles: (number | string)[]): void {
		this.role_ids = roles.map((role) => {
			if (typeof role === "string") return ROLES.indexOf(role);
			return role;
		});
		this.roles = this.role_ids.map((role) => {
			if (typeof role === "number") return ROLES[role];
			return role;
		});
	}
	static fromJWT(payload: JWT_REGISTERED_CLAIMS): User {
		let user = new User({
			id: payload.sub,
			first_name: payload.fnm,
			last_name: payload.lnm,
			role_ids: payload.rls,
		});
		return user;
	}
}
export interface UserRole {
	role_id: number;
	user_id: Buffer;
}
export interface PasswordRequirements {
	/**
	 * The minimum length of the password.
	 */
	min_length: number;
	/**
	 * The maximum length of the password.
	 */
	max_length: number;
	/**
	 * The minimum number of uppercase characters in the password.
	 */
	min_uppercase: number;
	/**
	 * The minimum number of lowercase characters in the password.
	 */
	min_lowercase: number;
	/**
	 * The minimum number of numerical digits in the password.
	 */
	min_digits: number;
	/**
	 * The minimum number of non-alphanumeric characters in the password.
	 */
	min_non_alphanumeric: number;
}
/*

*****Collections*****

*/
export type CollectionTypeString =
	| "email"
	| "binary"
	| "create-password"
	| "get-password"
	| "choice"
	| "telephone"
	| "text"
	| "url"
	| "show-document";
export interface CollectionTypeBase {
	type: CollectionTypeString;
}
export interface ChoiceCollectionType extends CollectionTypeBase {
	type: "choice";
	options: string;
}
export interface BinaryCollectionType extends CollectionTypeBase {
	type: "binary";
	submits: boolean;
}
export interface ShowDocumentCollectionType extends CollectionTypeBase {
	type: "show-document";
	html: string;
	required: boolean;
}
export interface CreatePasswordCollectionType extends CollectionTypeBase {
	type: "create-password";
	requirements: PasswordRequirements;
}
export interface OtherCollectionType extends CollectionTypeBase {
	type: "email" | "get-password" | "telephone" | "text" | "url";
}
export type CollectionType =
	| OtherCollectionType
	| ChoiceCollectionType
	| ShowDocumentCollectionType
	| CreatePasswordCollectionType
	| BinaryCollectionType;

/*

*****Actions*****

*/
export interface ActionBase {
	action:
		| "collect"
		| "register-passkey"
		| "authenticate-passkey"
		| "show-use-passkey-button"
		| "show-use-password-button"
		| "init-conditional-ui"
		| "exit"
		| "set-authentication-options"
		| "redirect"
		| "success"
		| "reset-form"
		| "error"
		| "reload";
}
export interface CollectAction extends ActionBase {
	action: "collect";
	/**
	 * A header to display during collection.
	 */
	header: string;
	/**
	 * A message to display during collection.
	 */
	message: string;
	/**
	 * Items to collect.
	 */
	types: CollectionType[];
	/**
	 * An array of options for collection type "choice".
	 */
	options?: string[];
}
export interface RegisterPasskeyAction extends ActionBase {
	action: "register-passkey";
	WebAuthnOptions: PublicKeyCredentialCreationOptionsJSON;
}
export interface AuthenticatePasskeyAction extends ActionBase {
	action: "authenticate-passkey";
	WebAuthnOptions: PublicKeyCredentialRequestOptionsJSON;
}
export interface SetAuthenticationOptionsAction extends ActionBase {
	action: "set-authentication-options";
	authenticationOptions: PublicKeyCredentialRequestOptionsJSON;
}
export interface RedirectAction extends ActionBase {
	action: "redirect";
	path: string;
}
export interface ErrorAction extends ActionBase {
	action: "error";
	errors: string[];
}
export interface OtherAction extends ActionBase {
	action:
		| "show-use-passkey-button"
		| "show-use-password-button"
		| "init-conditional-ui"
		| "exit"
		| "success"
		| "reset-form"
		| "reload";
}
export type Action =
	| OtherAction
	| CollectAction
	| RegisterPasskeyAction
	| AuthenticatePasskeyAction
	| SetAuthenticationOptionsAction
	| RedirectAction
	| ErrorAction;
export interface SetCookieOptions {
	name: string;
	value: string;
	expires?: Date;
	httpOnly?: boolean;
	signed?: boolean;
	secure?: boolean;
	path?: string;
	sameSite?: "strict" | "lax" | "none";
}
export interface LoginData {
	/**
	 * An object of cookies to be set in the response.
	 */
	setCookies?: SetCookieOptions[];
	actions?: Action[];
	data?: object;
}

export interface LoginInitializationOptions {
	supportsWebAuthn: boolean;
	supportsConditionalUI: boolean;
	/**
	 * If true, then this page has no login UI and should only use the Conditional UI (passkey, if one is saved for this site)
	 */
	conditionalUIOnly?: boolean;
}
export interface LoginDataReturnBase {
	/**
	 * The login session id.
	 */
	type:
		| "attestation-response"
		| "success"
		| "assertion-response"
		| "none"
		| "assertion-response"
		| "input";
}
export interface AttestationResponseLoginDataReturn
	extends LoginDataReturnBase {
	type: "attestation-response";
	/**
	 * The attestation response.
	 */
	attestationResponse: RegistrationResponseJSON;
}
export interface AssertionResponseLoginDataReturn extends LoginDataReturnBase {
	type: "assertion-response";
	/**
	 * The attestation response.
	 */
	assertionResponse: AuthenticationResponseJSON;
}
export interface InputLoginDataReturn extends LoginDataReturnBase {
	type: "input";
	values: {
		[key in CollectionTypeString]?: any;
	};
}
export interface OtherLoginDataReturn extends LoginDataReturnBase {
	type: "success" | "none";
}
export type LoginDataReturn =
	| OtherLoginDataReturn
	| AttestationResponseLoginDataReturn
	| AssertionResponseLoginDataReturn
	| InputLoginDataReturn;
export interface LoginDataReturnPacket {
	request: FastifyRequest;
	reply: FastifyReply;
	return: LoginDataReturn[];
}

export interface FileFields {
	[key: string]: {
		filename: string;
		tag: string;
	};
}
export interface UpdateUserInformationParameters {
	"set-first-name"?: string;
	"set-last-name"?: string;
	"add-email"?: string;
	"remove-emails"?: string[];
	"set-primary-email"?: string;
}
export type Filename = string;
export interface Directory {
	name: string;
	path?: string;
	contents: (Filename | Directory)[];
}
export interface FileData {
	filename: string;
	tag: string;
	file: File;
}
export interface ElementState {
	id: string | null;
	classes: string[];
	tag: string;
	parent: ElementState | null;
	children: ElementState[];
	innerText: string;
	innerHTML: string;
}
export interface PageEditCommand {
	command_type: string;
	command_target: HTMLElement;
	command_target_parent?: HTMLElement;
	command_target_index?: number;
	value?: any;
	previousState?: any;
	input?: HTMLElement;
	command_target_state: ElementState;
}
