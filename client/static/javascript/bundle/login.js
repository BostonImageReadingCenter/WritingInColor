/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./client/static/javascript/login.ts":
/*!*******************************************!*\
  !*** ./client/static/javascript/login.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.ts */ \"./client/static/javascript/utils.ts\");\n/* harmony import */ var _simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @simplewebauthn/browser */ \"./node_modules/@simplewebauthn/browser/dist/bundle/index.js\");\n\n\nvar collectionMessageEl, collectionHeaderEl, collectionFormEl, collectionInputsEl, hiddenData, sessionID, supportsWebAuthn, supportsConditionalUI, authenticationOptions;\nwindow.addEventListener(\"load\", async event => {\n  supportsWebAuthn = window.PublicKeyCredential && navigator.credentials && typeof navigator.credentials.create === \"function\" && typeof navigator.credentials.get === \"function\";\n  supportsConditionalUI = typeof PublicKeyCredential.isConditionalMediationAvailable === \"function\" && (await PublicKeyCredential.isConditionalMediationAvailable());\n  collectionMessageEl = document.getElementById(\"collection-message\");\n  collectionHeaderEl = document.getElementById(\"collection-header\");\n  collectionFormEl = document.getElementById(\"collection-form\");\n  collectionInputsEl = document.getElementById(\"collection-inputs\");\n  hiddenData = document.getElementById(\"hidden-data\");\n  fetch(\"/api/login/init\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      supportsWebAuthn,\n      supportsConditionalUI\n    })\n  }).then(async response => {\n    let json = await response.json();\n    sessionID = json.id;\n    authenticationOptions = json.value.authenticationOptions;\n    handleAction(json.value);\n    if (json.done) return;\n  });\n});\nasync function handleAction(data) {\n  console.log(data);\n  let actions = data.actions;\n  for (let item of actions) {\n    if (item.action === \"collect\") {\n      collect(item);\n    } else if (item.action === \"register-passkey\") {\n      registerPasskey(item);\n    } else if (item.action === \"authenticate-passkey\") {\n      authenticatePasskey(item);\n    } else if (item.action === \"init-conditional-ui\") {\n      initConditionalUI(item);\n    } else if (item.action === \"show-use-passkey-button\") {\n      showUsePasskeyButton(item);\n    } else if (item.action === \"exit\") {\n      // Reload\n      window.location.reload();\n    } else if (item.action === \"set-authentication-options\") {\n      authenticationOptions = item.authenticationOptions;\n    } else if (item.action === \"redirect\") {\n      window.location.href = item.path;\n    }\n  }\n}\nasync function returnData(data) {\n  fetch(\"/api/login/return\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      id: sessionID,\n      ...data\n    })\n  }).then(async response => {\n    let json = await response.json();\n    // console.log(json);\n    handleAction(json.value);\n    if (json.done) return;\n  });\n}\nasync function collect(data) {\n  collectionMessageEl.innerText = data.message;\n  collectionHeaderEl.innerText = data.header;\n  collectionInputsEl.innerHTML = \"\";\n  if (data.type === \"email\") {\n    let emailInputEl = (0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"input\", {\n      attributes: {\n        type: \"email\",\n        name: \"email\",\n        placeholder: \"Email\",\n        required: true,\n        autocomplete: \"email\"\n      },\n      classes: [],\n      id: \"\"\n    });\n    collectionInputsEl.appendChild(emailInputEl);\n    let listener = async event => {\n      event.preventDefault();\n      hiddenData.appendChild((0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"input\", {\n        attributes: {\n          type: \"email\",\n          name: \"email\",\n          value: emailInputEl.value,\n          autocomplete: \"email\",\n          style: \"display: none;\"\n        },\n        classes: [],\n        id: \"\"\n      }));\n      returnData({\n        value: emailInputEl.value\n      });\n    };\n    collectionFormEl.addEventListener(\"submit\", listener, {\n      once: true\n    });\n  } else if (data.type === \"binary\") {\n    let yesButtonEl = (0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"button\", {\n      attributes: {},\n      classes: [],\n      id: \"\",\n      text: \"yes\"\n    });\n    let noButtonEl = (0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"button\", {\n      attributes: {},\n      classes: [],\n      id: \"\",\n      text: \"no\"\n    });\n    collectionInputsEl.appendChild(yesButtonEl);\n    collectionInputsEl.appendChild(noButtonEl);\n    yesButtonEl.addEventListener(\"click\", async event => {\n      returnData({\n        value: true\n      });\n    }, {\n      once: true\n    });\n    noButtonEl.addEventListener(\"click\", async event => {\n      returnData({\n        value: false\n      });\n    }, {\n      once: true\n    });\n  } else if (data.type === \"choice\") {\n    // Using radio buttons\n    for (let i = 0; i < data.options.length; i++) {\n      let choiceInputEl = (0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"input\", {\n        attributes: {\n          type: \"radio\",\n          name: \"choice\",\n          value: i,\n          required: true\n        },\n        classes: [],\n        id: \"\"\n      });\n      collectionInputsEl.appendChild(choiceInputEl);\n      let choiceLabelEl = (0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"label\", {\n        attributes: {\n          for: \"choice\"\n        },\n        classes: [],\n        id: \"\"\n      });\n      choiceLabelEl.innerText = data.options[i];\n      collectionInputsEl.appendChild(choiceLabelEl);\n    }\n    collectionFormEl.addEventListener(\"submit\", async event => {\n      event.preventDefault();\n      const selectedOption = document.querySelector('input[name=\"choice\"]:checked');\n      returnData({\n        value: parseInt(selectedOption.value)\n      });\n    }, {\n      once: true\n    });\n  } else if (data.type === \"create-password\") {\n    let passwordInputEl = (0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"input\", {\n      attributes: {\n        type: \"password\",\n        name: \"password\",\n        placeholder: \"Password\",\n        required: true,\n        autocomplete: \"new-password\"\n      },\n      classes: [],\n      id: \"\"\n    });\n    let passwordConfirmInputEl = (0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"input\", {\n      attributes: {\n        type: \"password\",\n        placeholder: \"Confirm Password\",\n        required: true,\n        autocomplete: \"new-password\"\n      },\n      classes: [],\n      id: \"\"\n    });\n    collectionInputsEl.appendChild(passwordInputEl);\n    collectionInputsEl.appendChild(passwordConfirmInputEl);\n    let listener = async event => {\n      event.preventDefault();\n      if (passwordInputEl.value !== passwordConfirmInputEl.value) {\n        alert(\"Passwords do not match.\");\n        return;\n      }\n      hiddenData.appendChild((0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"input\", {\n        attributes: {\n          type: \"password\",\n          name: \"password\",\n          value: passwordInputEl.value,\n          autocomplete: \"current-password\",\n          style: \"display: none;\"\n        },\n        classes: [],\n        id: \"\"\n      }));\n      returnData({\n        value: passwordInputEl.value\n      });\n    };\n    collectionFormEl.addEventListener(\"submit\", listener, {\n      once: true\n    });\n  } else if (data.type === \"get-password\") {\n    let passwordInputEl = (0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"input\", {\n      attributes: {\n        type: \"password\",\n        placeholder: \"Password\",\n        required: true,\n        autocomplete: \"current-password\"\n      },\n      classes: [],\n      id: \"\"\n    });\n    collectionInputsEl.appendChild(passwordInputEl);\n    collectionFormEl.addEventListener(\"submit\", async event => {\n      event.preventDefault();\n      hiddenData.appendChild((0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"input\", {\n        attributes: {\n          type: \"password\",\n          name: \"password\",\n          style: \"display: none;\",\n          value: passwordInputEl.value,\n          autocomplete: \"current-password\"\n        },\n        classes: [],\n        id: \"\"\n      }));\n      returnData({\n        value: passwordInputEl.value\n      });\n    });\n  } else if (data.type === \"telephone\") {\n    let telephoneInputEl = (0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"input\", {\n      attributes: {\n        type: \"tel\",\n        placeholder: \"Telephone\",\n        required: true,\n        autocomplete: \"tel webauthn\"\n      },\n      classes: [],\n      id: \"\"\n    });\n    collectionInputsEl.appendChild(telephoneInputEl);\n    collectionFormEl.addEventListener(\"submit\", async event => {\n      event.preventDefault();\n      hiddenData.appendChild((0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"input\", {\n        attributes: {\n          type: \"tel\",\n          name: \"tel\",\n          value: telephoneInputEl.value,\n          autocomplete: \"tel\",\n          style: \"display: none;\"\n        },\n        classes: [],\n        id: \"\"\n      }));\n      returnData({\n        value: telephoneInputEl.value\n      });\n    }, {\n      once: true\n    });\n  }\n}\nasync function registerPasskey(data) {\n  const attestationResponse = await (0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.startRegistration)(data.WebAuthnOptions);\n  const verificationResponse = await fetch(\"/api/login/return\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      id: sessionID,\n      attestationResponse\n    })\n  });\n  let json = await verificationResponse.json();\n  handleAction(json.value);\n  if (json.value.data.success) {\n    if (!json.done) returnData({});\n    // TODO: handle success\n  } else {\n    alert(\"Registration Failed.\");\n    // TODO: handle failure\n  }\n}\nasync function authenticatePasskey() {\n  let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    action: \"authenticate-passkey\",\n    WebAuthnOptions: null\n  };\n  let WebAuthnOptions = authenticationOptions;\n  if (data.WebAuthnOptions) {\n    WebAuthnOptions = data.WebAuthnOptions;\n  }\n  const assertionResponse = await (0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.startAuthentication)(WebAuthnOptions);\n  const verificationResponse = await fetch(\"/api/login/return\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      id: sessionID,\n      assertionResponse\n    })\n  });\n  let json = await verificationResponse.json();\n  handleAction(json.value);\n  if (json.value.data.success) {\n    if (!json.done) returnData({});\n    // TODO: handle success\n  } else {\n    alert(\"Authentication Failed.\");\n    // TODO: handle failure\n  }\n}\nasync function initConditionalUI(data) {\n  if (!supportsWebAuthn) {\n    return;\n  }\n  if (supportsConditionalUI) {\n    if (!(typeof PublicKeyCredential.isConditionalMediationAvailable === \"function\" && PublicKeyCredential.isConditionalMediationAvailable())) {\n      return;\n    }\n    (0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.startAuthentication)(authenticationOptions, true).then(async assertionResponse => {\n      const verificationResponse = await fetch(\"/api/login/return\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: sessionID,\n          assertionResponse\n        })\n      });\n      let json = await verificationResponse.json();\n      handleAction(json.value);\n      if (json.value.data.success) {\n        // TODO: handle success\n        if (!json.done) returnData({});\n      } else {\n        alert(\"Login Failure!\");\n        // TODO: handle failure\n      }\n    }).catch(async err => {\n      console.log(err);\n      // TODO: handle failure\n    });\n  }\n}\nasync function showUsePasskeyButton(data) {\n  let usePasskeyButton = (0,_utils_ts__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"button\", {\n    attributes: {},\n    classes: [],\n    id: \"usePasskey\"\n  });\n  usePasskeyButton.innerText = \"Sign in with a passkey\";\n  usePasskeyButton.addEventListener(\"click\", async event => {\n    await authenticatePasskey();\n  }, {\n    once: true\n  });\n  collectionFormEl.appendChild(usePasskeyButton);\n}\n\n//# sourceURL=webpack://writingincolor/./client/static/javascript/login.ts?");

/***/ }),

/***/ "./client/static/javascript/utils.ts":
/*!*******************************************!*\
  !*** ./client/static/javascript/utils.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createElement: () => (/* binding */ createElement)\n/* harmony export */ });\nconst newProperties = {\n  setClass() {\n    for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {\n      classes[_key] = arguments[_key];\n    }\n    for (let c of classes) {\n      this.classList.add(c);\n    }\n    return this;\n  },\n  setId(id) {\n    this.id = id;\n    return this;\n  },\n  setText(text) {\n    this.innerText = text;\n    return this;\n  },\n  setHTML(HTML) {\n    this.innerHTML = HTML;\n    return this;\n  }\n};\n// Define function overloads\n\n// Implementation\nfunction createElement(elementTypeOrOptions, options) {\n  let elementType = typeof elementTypeOrOptions === \"string\" ? elementTypeOrOptions : elementTypeOrOptions.tag;\n  options = typeof elementTypeOrOptions === \"string\" ? options : elementTypeOrOptions;\n  let element = document.createElement(elementType, options);\n  for (let attribute in options.attributes ?? {}) {\n    element.setAttribute(attribute, options.attributes[attribute]);\n  }\n  for (let c of options.classes ?? []) {\n    element.classList.add(c);\n  }\n  if (options.id) {\n    element.id = options.id;\n  }\n  if (options.text) {\n    element.innerText = options.text;\n  }\n  if (options.html) {\n    element.innerHTML = options.html;\n  }\n  for (let child of options.children ?? []) {\n    if (child instanceof Element) {\n      element.appendChild(child);\n    } else {\n      element.appendChild(createElement(child));\n    }\n  }\n  for (let handler in options.eventHandlers ?? {}) {\n    element.addEventListener(handler, options.eventHandlers[handler]);\n  }\n  return element;\n}\nfunction extendElementPrototype() {\n  Object.keys(newProperties).forEach(methodName => {\n    Element.prototype[methodName] = newProperties[methodName];\n  });\n}\n\n// Extend the prototype\nextendElementPrototype();\n\n\n//# sourceURL=webpack://writingincolor/./client/static/javascript/utils.ts?");

/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/dist/bundle/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/dist/bundle/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebAuthnAbortService: () => (/* binding */ WebAuthnAbortService),\n/* harmony export */   WebAuthnError: () => (/* binding */ WebAuthnError),\n/* harmony export */   base64URLStringToBuffer: () => (/* binding */ base64URLStringToBuffer),\n/* harmony export */   browserSupportsWebAuthn: () => (/* binding */ browserSupportsWebAuthn),\n/* harmony export */   browserSupportsWebAuthnAutofill: () => (/* binding */ browserSupportsWebAuthnAutofill),\n/* harmony export */   bufferToBase64URLString: () => (/* binding */ bufferToBase64URLString),\n/* harmony export */   platformAuthenticatorIsAvailable: () => (/* binding */ platformAuthenticatorIsAvailable),\n/* harmony export */   startAuthentication: () => (/* binding */ startAuthentication),\n/* harmony export */   startRegistration: () => (/* binding */ startRegistration)\n/* harmony export */ });\n/* [@simplewebauthn/browser@10.0.0] */\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return (window?.PublicKeyCredential !== undefined &&\n        typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        super(message, { cause });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nclass BaseWebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nconst WebAuthnAbortService = new BaseWebAuthnAbortService();\n\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n\nasync function startRegistration(optionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        user: {\n            ...optionsJSON.user,\n            id: base64URLStringToBuffer(optionsJSON.user.id),\n        },\n        excludeCredentials: optionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n\nfunction browserSupportsWebAuthnAutofill() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    const globalPublicKeyCredential = window\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential.isConditionalMediationAvailable === undefined) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return globalPublicKeyCredential.isConditionalMediationAvailable();\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nasync function startAuthentication(optionsJSON, useBrowserAutofill = false) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (optionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = optionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToBase64URLString(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nfunction platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\n\n\n\n//# sourceURL=webpack://writingincolor/./node_modules/@simplewebauthn/browser/dist/bundle/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./client/static/javascript/login.ts");
/******/ 	
/******/ })()
;